{"projectName":"problem_3_3","totalTests":2,"passed":2,"failed":0,"skipped":0,"coveredLines":182,"missedLines":171,"coveragePercentage":51.56,"moduleStatus":[{"name":"problem_3_3","totalTests":2,"passed":2,"failed":0,"skipped":0,"tests":[{"name":"testFindTheGiftComplex","status":"PASSED"},{"name":"testFindTheGiftSimple","status":"PASSED"}]},{"name":"problem_3_3.back_ends","totalTests":0,"passed":0,"failed":0,"skipped":0,"tests":[]}],"moduleCoverage":[{"name":"problem_3_3","coveredLines":37,"missedLines":4,"coveragePercentage":90.24,"sourceFiles":[{"name":"main.bal","coveredLines":[19,20,22,25,26,29,32,33,36,37,38,39,42,43,46,47,48,49,52,53,54,56,57,58,59,60,61,63,64,68,69,70,71,77,78,88,94],"missedLines":[23,28,44,65],"coveragePercentage":90.24,"sourceCode":"import ballerina/io;\nimport ballerina/http;\n// import ballerina/io;\n// import problem_3_3.back_ends as _;\n\nhttp:OAuth2RefreshTokenGrantConfig activitiesConfig \u003d {\n    refreshToken: refreshToken,\n    refreshUrl: tokenEndpoint,\n    clientId: clientId,\n    clientSecret: clientSecret, clientConfig: {secureSocket: {cert: \"resources/public.crt\"}}\n};\n\nhttp:ClientAuthConfig insureConfig \u003d {\n        username: \"alice\",\n        password: \"123\"\n    };\n\nfunction giftTypeFromScore(int score) returns Types? {\n    if score \u003e\u003d SILVER_BAR \u0026\u0026 score \u003c GOLD_BAR {\n        return SILVER;\n    }\n    if score \u003e\u003d GOLD_BAR \u0026\u0026 score \u003c PLATINUM_BAR {\n        return GOLD;\n    }\n    if score \u003e\u003d PLATINUM_BAR {\n        return PLATINUM;\n    }\n    return;\n}\n\nfunction findTheGiftSimple(string userID, string \u0027from, string to) returns Gift|error {\n    final http:Client fifitEp \u003d check new(\"https://localhost:9091/activities\", auth \u003d activitiesConfig, secureSocket \u003d {\n        cert: \"resources/public.crt\"\n    });\n\n    Activities activites \u003d check fifitEp-\u003eget(\"/steps/user/\" + userID + \"/from/\" + \u0027from + \"/to/\" + to);\n    int steps \u003d 0;\n    foreach var activity in activites.activities\\-steps {\n        steps +\u003d activity.value;\n    }\n\n    Types? giftType \u003d giftTypeFromScore(steps);\n    if giftType is () {\n        return {eligible: false, \u0027from, to, score: steps};\n    }\n    GiftDetails giftDetails \u003d {\u0027type: giftType, message: \"Congratulations! You have won the \" + giftType + \" gift!\"};\n    Gift gift \u003d {eligible: true, \u0027from, to, score: steps, details: giftDetails};\n    return gift;\n}\n\nfunction findTheGiftComplex(string userID, string \u0027from, string to) returns Gift|error {\n    io:println(\"here\");\n    final http:Client insureEveryoneEp \u003d check new(\"https://localhost:9092/insurance\", auth \u003d insureConfig, secureSocket \u003d {\n        cert: \"resources/public.crt\"\n    });\n    io:println(\"here\");\n    Gift oldGift \u003d check findTheGiftSimple(userID, \u0027from, to);\n    io:println(\"here\");\n    record {|record {int age;} user;|} res \u003d check insureEveryoneEp-\u003eget(\"/user/\" + userID);\n    int age \u003d res.user.age;\n    int score \u003d oldGift.score/((100-age)/10);\n\n    Types? giftType \u003d giftTypeFromScore(score);\n    if giftType is () {\n        return {eligible: false, \u0027from, to, score};\n    }\n\n    GiftDetails giftDetails \u003d {\u0027type: giftType, message: \"Congratulations! You have won the \" + giftType + \" gift!\"};\n    Gift gift \u003d {eligible: true, \u0027from, to, score, details: giftDetails};\n    return gift;\n}\n\ntype Activities record {\n    record {|\n        string date;\n        int value;\n    |}[] activities\\-steps;\n};\n\ntype Gift record {\n    boolean eligible;\n    int score;\n    # format yyyy-mm-dd\n    string \u0027from;\n    # format yyyy-mm-dd\n    string to;\n    GiftDetails details?;  \n};\n\ntype GiftDetails record {\n    Types \u0027type;\n    # message string: Congratulations! You have won the ${type} gift!;\n    string message;\n};\n\nenum Types {\n    SILVER,\n    GOLD,\n    PLATINUM\n}\n\nconst int SILVER_BAR \u003d 5000;\nconst int GOLD_BAR \u003d 10000;\nconst int PLATINUM_BAR \u003d 20000;\n"}]},{"name":"problem_3_3.back_ends","coveredLines":145,"missedLines":167,"coveragePercentage":46.47,"sourceFiles":[{"name":"fitfit_steps_api.bal","coveredLines":[17,18,19,20,21,22,23,24,25,26,33,36,37,39,40,41,42,44,45,49,50,52,53],"missedLines":[46],"coveragePercentage":95.83,"sourceCode":"import ballerina/os;\nimport ballerina/io;\nimport ballerina/log;\nimport ballerina/http;\n\nconfigurable int fitfit_port \u003d 9091;\n\nlistener http:Listener fifit_ls \u003d new (fitfit_port, {\n    secureSocket: {\n        key: {\n            certFile: \"./resources/public.crt\",\n            keyFile: \"./resources/private.key\"\n        }\n    }\n});\n\n@http:ServiceConfig {\n    auth: [\n        {\n            oauth2IntrospectionConfig: {\n                url: \"https://localhost:9445/oauth2/introspect\",\n                tokenTypeHint: \"access_token\",\n                clientConfig: {\n                    customHeaders: {\"Authorization\": \"Basic YWRtaW46YWRtaW4\u003d\"},\n                    secureSocket: {\n                        cert: \"./resources/public.crt\"\n                    }\n                }\n            }\n        }\n    ]\n}\nservice /activities on fifit_ls {\n\n    function init() {\n        log:printInfo(\"Fitfit steps API started\", host \u003d \"0.0.0.0\", port \u003d fitfit_port, protocol \u003d \"HTTPS\");\n    }\n\n    resource function get steps/user/[string id]/\u0027from/[string fromDate]/to/[string toDate]() returns json|error {\n        string dataSource \u003d os:getEnv(\"DATA_SOURCE\");\n        if dataSource \u003d\u003d \"\" {\n            dataSource \u003d \"resources/data.json\";\n        }\n        json|io:Error data \u003d io:fileReadJson(dataSource);\n        if data is io:Error {\n            return error(\"Failed to load data\");\n        }\n        \n        return {\n            \"activities-steps\": check data.stepsActivity\n        };\n    }\n}\n"},{"name":"sts.bal","coveredLines":[36,39,40,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,60,62,64,65,68,73,126,128,129,130,131,132,133,134,135,136,137,138,139,142,145,146,149,159,191,194,213,239,240,241,242,243,244,245,246,247,248,249,250,251,253,261,262,289,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,310,311,316,319,320,321,322,325,326,327,328,331,332,333,336,337,338],"missedLines":[59,61,63,69,75,76,78,79,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,109,110,114,115,117,118,120,121,123,124,143,151,152,154,155,157,158,163,164,165,166,167,168,169,170,171,173,174,175,176,177,178,180,181,182,183,184,185,186,189,190,195,196,197,198,199,200,201,203,204,205,206,208,209,211,212,214,215,216,217,218,219,220,221,222,223,224,226,227,228,229,231,232,234,235,237,238,254,255,256,258,259,265,266,267,268,269,270,271,272,273,274,276,277,278,279,281,282,284,285,287,288,314,315,342,343,344,345,348,351,352,353,354,357,360,361,362,363,366,369,370,371,372,375,378,379,380,381,384],"coveragePercentage":37.31,"sourceCode":"import ballerina/http;\nimport ballerina/regex;\nimport ballerina/log;\nimport ballerina/uuid;\n\n// Default values of mock authorization server.\nconfigurable int STS_SERVER_PORT \u003d 9445;\nconfigurable int STS_TOKEN_VALIDITY_PERIOD \u003d 3600; // in seconds\n\n// Credentials of the mock authorization server.\nconfigurable string STS_USERNAME \u003d \"admin\";\nconfigurable string STS_PASSWORD \u003d \"admin\";\nconfigurable string STS_CLIENT_ID \u003d \"FlfJYKBD2c925h4lkycqNZlC2l4a\";\nconfigurable string STS_CLIENT_SECRET \u003d \"PJz0UhTJMrHOo68QQNpvnqAY_3Aa\";\n\n// Values that the grant_type parameter can hold.\nconst GRANT_TYPE_CLIENT_CREDENTIALS \u003d \"client_credentials\";\nconst GRANT_TYPE_PASSWORD \u003d \"password\";\nconst GRANT_TYPE_REFRESH_TOKEN \u003d \"refresh_token\";\nconst GRANT_TYPE_JWT_BEARER \u003d \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n\nstring[] accessTokenStore \u003d [\"56ede317-4511-44b4-8579-a08f094ee8c5\"];\nstring[] refreshTokenStore \u003d [\"24f19603-8565-4b5f-a036-88a945e1f272\"];\n\n// The mock authorization server, which is capable of issuing access tokens with related to the grant type and\n// also of refreshing the already-issued access tokens. Also, capable of introspection the access tokens.\nlistener http:Listener sts \u003d new (STS_SERVER_PORT, {\n    secureSocket: {\n        key: {\n            certFile: \"./resources/public.crt\",\n            keyFile: \"./resources/private.key\"\n        }\n    }\n});\n\nservice /oauth2 on sts {\n\n    function init() {\n        log:printInfo(\"STS endpoint started\", host \u003d \"0.0.0.0\", port \u003d STS_SERVER_PORT, protocol \u003d \"HTTPS\");\n    }\n\n    // This issues an access token with reference to the received grant type (client credentials, password and refresh token grant type).\n    resource function post token(http:Request req) returns http:Ok|http:Unauthorized|http:BadRequest|http:InternalServerError {\n        var authorizationHeader \u003d req.getHeader(\"Authorization\");\n        if authorizationHeader is string {\n            if isAuthorizedTokenClient(authorizationHeader) {\n                var payload \u003d req.getTextPayload();\n                if payload is string {\n                    string[] params \u003d regex:split(payload, \"\u0026\");\n                    string grantType \u003d \"\";\n                    string scopes \u003d \"\";\n                    string username \u003d \"\";\n                    string password \u003d \"\";\n                    string refreshToken \u003d \"\";\n                    foreach string param in params {\n                        if param.includes(\"grant_type\u003d\") {\n                            grantType \u003d regex:split(param, \"\u003d\")[1];\n                        } else if param.includes(\"scope\u003d\") {\n                            scopes \u003d regex:split(param, \"\u003d\")[1];\n                        } else if param.includes(\"username\u003d\") {\n                            username \u003d regex:split(param, \"\u003d\")[1];\n                        } else if param.includes(\"password\u003d\") {\n                            password \u003d regex:split(param, \"\u003d\")[1];\n                        } else if param.includes(\"refresh_token\u003d\") {\n                            refreshToken \u003d regex:split(param, \"\u003d\")[1];\n                            // If the refresh token contains the `\u003d` symbol, then it is required to concatenate all the parts of the value since\n                            // the `split` function breaks all those into separate parts.\n                            if param.endsWith(\"\u003d\u003d\") {\n                                refreshToken +\u003d \"\u003d\u003d\";\n                            }\n                        }\n                    }\n                    return prepareTokenResponse(grantType, username, password, refreshToken, scopes);\n                }\n                string description \u003d \"The request is malformed and failed to retrieve the text payload.\";\n                return createInvalidRequest(description);\n            }\n            string description \u003d \"Client authentication failed due to unknown client.\";\n            return createInvalidClient(description);\n        } else {\n            var payload \u003d req.getTextPayload();\n            if payload is string {\n                if payload.includes(\"client_id\") \u0026\u0026 payload.includes(\"client_secret\") {\n                    string[] params \u003d regex:split(payload, \"\u0026\");\n                    string grantType \u003d \"\";\n                    string scopes \u003d \"\";\n                    string username \u003d \"\";\n                    string password \u003d \"\";\n                    string clientId \u003d \"\";\n                    string clientSecret \u003d \"\";\n                    string refreshToken \u003d \"\";\n                    foreach string param in params {\n                        if param.includes(\"grant_type\u003d\") {\n                            grantType \u003d regex:split(param, \"\u003d\")[1];\n                        } else if param.includes(\"scope\u003d\") {\n                            scopes \u003d regex:split(param, \"\u003d\")[1];\n                        } else if param.includes(\"username\u003d\") {\n                            username \u003d regex:split(param, \"\u003d\")[1];\n                        } else if param.includes(\"password\u003d\") {\n                            password \u003d regex:split(param, \"\u003d\")[1];\n                        } else if param.includes(\"client_id\u003d\") {\n                            clientId \u003d regex:split(param, \"\u003d\")[1];\n                        } else if param.includes(\"client_secret\u003d\") {\n                            clientSecret \u003d regex:split(param, \"\u003d\")[1];\n                        } else if param.includes(\"refresh_token\u003d\") {\n                            refreshToken \u003d regex:split(param, \"\u003d\")[1];\n                            // If the refresh token contains the `\u003d` symbol, then it is required to concatenate all the parts of the value since\n                            // the `split` function breaks all those into separate parts.\n                            if param.endsWith(\"\u003d\u003d\") {\n                                refreshToken +\u003d \"\u003d\u003d\";\n                            }\n                        }\n                    }\n                    if clientId \u003d\u003d STS_CLIENT_ID \u0026\u0026 clientSecret \u003d\u003d STS_CLIENT_SECRET {\n                        return prepareTokenResponse(grantType, username, password, refreshToken, scopes);\n                    }\n                    string description \u003d \"Client authentication failed since no client authentication included.\";\n                    return createInvalidClient(description);\n                }\n                string description \u003d \"Client authentication failed due to unknown client.\";\n                return createInvalidClient(description);\n            }\n            string description \u003d \"The request is malformed and failed to retrieve the text payload.\";\n            return createInvalidRequest(description);\n        }\n    }\n\n    resource function post introspect(http:Request req) returns http:Ok|http:Unauthorized|http:BadRequest {\n        var authorizationHeader \u003d req.getHeader(\"Authorization\");\n        if authorizationHeader is string {\n            if isAuthorizedIntrospectionClient(authorizationHeader) {\n                var payload \u003d req.getTextPayload();\n                if payload is string {\n                    string[] params \u003d regex:split(payload, \"\u0026\");\n                    string token \u003d \"\";\n                    string tokenTypeHint \u003d \"\";\n                    foreach string param in params {\n                        if param.includes(\"token\u003d\") {\n                            token \u003d regex:split(param, \"\u003d\")[1];\n                            // If the access token contains the `\u003d` symbol, then it is required to concatenate all the parts of the value since\n                            // the `split` function breaks all those into separate parts.\n                            if param.endsWith(\"\u003d\u003d\") {\n                                token +\u003d \"\u003d\u003d\";\n                            }\n                        } else if param.includes(\"token_type_hint\u003d\") {\n                            tokenTypeHint \u003d regex:split(param, \"\u003d\")[1];\n                        }\n                    }\n                    return prepareIntrospectionResponse(token, tokenTypeHint);\n                }\n                string description \u003d \"The request is malformed and failed to retrieve the text payload.\";\n                return createInvalidRequest(description);\n            }\n            string description \u003d \"Client authentication failed due to unknown client.\";\n            return createInvalidClient(description);\n        }\n        string description \u003d \"Client authentication failed since no client authentication included.\";\n        return createInvalidClient(description);\n    }\n\n    // This JWKs endpoint respond with a JSON object that represents a set of JWKs.\n    // https://tools.ietf.org/html/rfc7517#section-5\n    resource function get jwks() returns json {\n        json jwks \u003d {\n            \"keys\": [{\n                \"kty\": \"EC\",\n                \"crv\": \"P-256\",\n                \"x\": \"MKBCTNIcKUSDii11ySs3526iDZ8AiTo7Tu6KPAqv7D4\",\n                \"y\": \"4Etl6SRW2YiLUrN5vfvVHuhp7x8PxltmWWlbbM4IFyM\",\n                \"use\": \"enc\",\n                \"kid\": \"1\"\n            },\n            {\n                \"kty\": \"RSA\",\n                \"n\": \"0vx7agoebGcQSuuPiLJXZptN9nndrQmbXEps2aiAFbWhM78LhWx4cbbfAAtVT86zwu1RK7aPFFxuhDR1L6tSoc_BJECPebWKRXjBZCiFV4n3oknjhMstn64tZ_2W-5JsGY4Hc5n9yBXArwl93lqt7_RN5w6Cf0h4QyQ5v-65YGjQR0_FDW2QvzqY368QQMicAtaSqzs8KJZgnYb9c7d0zgdAZHzu6qMQvRL5hajrn1n91CbOpbISD08qNLyrdkt-bFTWhAI4vMQFh6WeZu0fM4lFd2NcRwr3XPksINHaQ-G_xBniIqbw0Ls1jF44-csFCur-kEgU8awapJzKnqDKgw\",\n                \"e\": \"AQAB\",\n                \"alg\": \"RS256\",\n                \"kid\": \"2011-04-29\"\n            },\n            {\n                \"kty\": \"RSA\",\n                \"e\": \"AQAB\",\n                \"use\": \"sig\",\n                \"kid\": \"NTAxZmMxNDMyZDg3MTU1ZGM0MzEzODJhZWI4NDNlZDU1OGFkNjFiMQ\",\n                \"alg\": \"RS256\",\n                \"n\": \"AIFcoun1YlS4mShJ8OfcczYtZXGIes_XWZ7oPhfYCqhSIJnXD3vqrUu4GXNY2E41jAm8dd7BS5GajR3g1GnaZrSqN0w3bjpdbKjOnM98l2-i9-JP5XoedJsyDzZmml8Xd7zkKCuDqZIDtZ99poevrZKd7Gx5n2Kg0K5FStbZmDbTyX30gi0_griIZyVCXKOzdLp2sfskmTeu_wF_vrCaagIQCGSc60Yurnjd0RQiMWA10jL8axJjnZ-IDgtKNQK_buQafTedrKqhmzdceozSot231I9dth7uXvmPSjpn23IYUIpdj_NXCIt9FSoMg5-Q3lhLg6GK3nZOPuqgGa8TMPs\u003d\"\n            }]\n        };\n        return jwks;\n    }\n}\n\nfunction prepareTokenResponse(string grantType, string username, string password, string refreshToken, string scopes) returns http:Ok|http:Unauthorized|http:BadRequest|http:InternalServerError {\n    if grantType \u003d\u003d GRANT_TYPE_CLIENT_CREDENTIALS {\n        string newAccessToken \u003d uuid:createType4AsString();\n        addToAccessTokenStore(newAccessToken);\n        json response \u003d {\n            \"access_token\": newAccessToken,\n            \"token_type\": \"example\",\n            \"expires_in\": STS_TOKEN_VALIDITY_PERIOD,\n            \"example_parameter\": \"example_value\"\n        };\n        if scopes !\u003d \"\" {\n            json|error mergedJson \u003d response.mergeJson({\"scope\": scopes});\n            if mergedJson is error {\n                return \u003chttp:InternalServerError\u003e {};\n            }\n            http:Ok ok \u003d {body: \u003cjson\u003e mergedJson};\n            return ok;\n        }\n        http:Ok ok \u003d {body: response};\n        return ok;\n    } else if grantType \u003d\u003d GRANT_TYPE_PASSWORD {\n        if username \u003d\u003d STS_USERNAME \u0026\u0026 password \u003d\u003d STS_PASSWORD {\n            string newAccessToken \u003d uuid:createType4AsString();\n            addToAccessTokenStore(newAccessToken);\n            string newRefreshToken \u003d uuid:createType4AsString();\n            addToRefreshTokenStore(newRefreshToken);\n            json response \u003d {\n                \"access_token\": newAccessToken,\n                \"refresh_token\": newRefreshToken,\n                \"token_type\": \"example\",\n                \"expires_in\": STS_TOKEN_VALIDITY_PERIOD,\n                \"example_parameter\": \"example_value\"\n            };\n            if scopes !\u003d \"\" {\n                json|error mergedJson \u003d response.mergeJson({\"scope\": scopes});\n                if mergedJson is error {\n                    return \u003chttp:InternalServerError\u003e {};\n                }\n                http:Ok ok \u003d {body: \u003cjson\u003e mergedJson};\n                return ok;\n            }\n            http:Ok ok \u003d {body: response};\n            return ok;\n        }\n        string description \u003d \"The authenticated client is not authorized to use password grant type.\";\n        return createUnauthorizedClient(description);\n    } else if grantType \u003d\u003d GRANT_TYPE_REFRESH_TOKEN {\n        foreach string token in refreshTokenStore {\n            if token \u003d\u003d refreshToken {\n                string newAccessToken \u003d uuid:createType4AsString();\n                addToAccessTokenStore(newAccessToken);\n                string newRefreshToken \u003d uuid:createType4AsString();\n                addToRefreshTokenStore(newRefreshToken);\n                json response \u003d {\n                    \"access_token\": newAccessToken,\n                    \"refresh_token\": newRefreshToken,\n                    \"token_type\": \"example\",\n                    \"expires_in\": STS_TOKEN_VALIDITY_PERIOD,\n                    \"example_parameter\": \"example_value\"\n                };\n                if scopes !\u003d \"\" {\n                    json|error mergedJson \u003d response.mergeJson({\"scope\": scopes});\n                    if mergedJson is error {\n                        return \u003chttp:InternalServerError\u003e {};\n                    }\n                    http:Ok ok \u003d {body: mergedJson};\n                    return ok;\n                }\n                http:Ok ok \u003d {body: response};\n                return ok;\n            }\n        }\n        string description \u003d \"The provided refresh token is invalid, expired or revoked.\";\n        return createInvalidGrant(description);\n    } else if grantType \u003d\u003d GRANT_TYPE_JWT_BEARER {\n        string newAccessToken \u003d uuid:createType4AsString();\n        addToAccessTokenStore(newAccessToken);\n        json response \u003d {\n            \"access_token\": newAccessToken,\n            \"token_type\": \"example\",\n            \"expires_in\": STS_TOKEN_VALIDITY_PERIOD,\n            \"example_parameter\": \"example_value\"\n        };\n        if scopes !\u003d \"\" {\n            json|error mergedJson \u003d response.mergeJson({\"scope\": scopes});\n            if mergedJson is error {\n                return \u003chttp:InternalServerError\u003e {};\n            }\n            http:Ok ok \u003d {body: \u003cjson\u003e mergedJson};\n            return ok;\n        }\n        http:Ok ok \u003d {body: response};\n        return ok;\n    }\n    string description \u003d \"The authorization grant type is not supported by the authorization server.\";\n    return createUnsupportedGrant(description);\n}\n\nfunction prepareIntrospectionResponse(string accessToken, string tokenTypeHint) returns http:Ok {\n    foreach string token in accessTokenStore {\n        if token \u003d\u003d accessToken {\n            json response \u003d {\n                \"active\": true,\n                \"scope\": \"read write dolphin\",\n                \"client_id\": \"l238j323ds-23ij4\",\n                \"username\": \"jdoe\",\n                \"token_type\": \"token_type\",\n                \"exp\": STS_TOKEN_VALIDITY_PERIOD,\n                \"iat\": 1419350238,\n                \"nbf\": 1419350238,\n                \"sub\": \"Z5O3upPC88QrAjx00dis\",\n                \"aud\": \"https://protected.example.net/resource\",\n                \"iss\": \"https://server.example.com/\",\n                \"jti\": \"JlbmMiOiJBMTI4Q0JDLUhTMjU2In\",\n                \"extension_field\": \"twenty-seven\",\n                \"scp\": \"admin\"\n            };\n            http:Ok ok \u003d {body: response};\n            return ok;\n        }\n    }\n    http:Ok ok \u003d {body: {\"active\": false}};\n    return ok;\n}\n\nfunction isAuthorizedTokenClient(string authorizationHeader) returns boolean {\n    string clientIdSecret \u003d STS_CLIENT_ID + \":\" + STS_CLIENT_SECRET;\n    string expectedAuthorizationHeader \u003d \"Basic \" + clientIdSecret.toBytes().toBase64();\n    return authorizationHeader \u003d\u003d expectedAuthorizationHeader;\n}\n\nfunction isAuthorizedIntrospectionClient(string authorizationHeader) returns boolean {\n    string usernamePassword \u003d STS_USERNAME + \":\" + STS_PASSWORD;\n    string expectedAuthorizationHeader \u003d \"Basic \" + usernamePassword.toBytes().toBase64();\n    return authorizationHeader \u003d\u003d expectedAuthorizationHeader;\n}\n\nfunction addToAccessTokenStore(string accessToken) {\n    int index \u003d accessTokenStore.length();\n    accessTokenStore[index] \u003d accessToken;\n}\n\nfunction addToRefreshTokenStore(string refreshToken) {\n    int index \u003d refreshTokenStore.length();\n    refreshTokenStore[index] \u003d refreshToken;\n}\n\n// Error responses. (Refer: https://tools.ietf.org/html/rfc6749#section-5.2)\nfunction createInvalidClient(string description) returns http:Unauthorized {\n    return {\n        body: {\n            \"error\": \"invalid_client\",\n            \"error_description\": description\n        }\n    };\n}\n\nfunction createUnauthorizedClient(string description) returns http:Unauthorized {\n    return {\n        body: {\n            \"error\": \"unauthorized_client\",\n            \"error_description\": description\n        }\n    };\n}\n\nfunction createInvalidRequest(string description) returns http:BadRequest {\n    return {\n        body: {\n            \"error\": \"invalid_request\",\n            \"error_description\": description\n        }\n    };\n}\n\nfunction createInvalidGrant(string description) returns http:BadRequest {\n    return {\n        body: {\n            \"error\": \"invalid_grant\",\n            \"error_description\": description\n        }\n    };\n}\n\nfunction createUnsupportedGrant(string description) returns http:BadRequest {\n    return {\n        body: {\n            \"error\": \"unsupported_grant_type\",\n            \"error_description\": description\n        }\n    };\n}\n"},{"name":"insure_everyone_user_api.bal","coveredLines":[19,22,23,25,26,27,28,30,31,32,34,35,39,40,42,43,46,47,48,49,50,51,52,54,62],"missedLines":[36,57,60],"coveragePercentage":89.29,"sourceCode":"import ballerina/os;\nimport ballerina/io;\nimport ballerina/auth;\nimport ballerina/log;\nimport ballerina/http;\n\nconfigurable int insureEveryonePort \u003d 9092;\nconfigurable string USER_SERVICE_USERNAME \u003d \"alice\";\nconfigurable string USER_SERVICE_PASSWORD \u003d \"123\";\n\nlistener http:Listener insureEveryoneListener \u003d new (insureEveryonePort, {\n    secureSocket: {\n        key: {\n            certFile: \"./resources/public.crt\",\n            keyFile: \"./resources/private.key\"\n        }\n    }\n});\nservice /insurance on insureEveryoneListener {\n\n    function init() {\n        log:printInfo(\"Insure everyone user API started\", host \u003d \"0.0.0.0\", port \u003d insureEveryonePort, protocol \u003d \"HTTPS\");\n    }\n\n    resource function get user/[string userId](@http:Header {name: \"Authorization\"} string header) returns json|http:Unauthorized|error {\n        http:Unauthorized? result \u003d authenticateUser(header);\n        if result is http:Unauthorized {\n            return result;\n        }\n         string dataSource \u003d os:getEnv(\"DATA_SOURCE\");\n        if dataSource \u003d\u003d \"\" {\n            dataSource \u003d \"resources/data.json\";\n        }\n        json|io:Error data \u003d io:fileReadJson(dataSource);\n        if data is io:Error {\n            return error(\"Failed to load data\");\n        }\n        \n        return {\n            \"user\": check data.user\n        };\n    }\n}\n\nfunction authenticateUser(string header) returns http:Unauthorized? {\n    if header.startsWith(http:AUTH_SCHEME_BASIC + \" \") {\n        string credential \u003d header.substring(6, header.length());\n        [string, string]|auth:Error result \u003d auth:extractUsernameAndPassword(credential);\n        if result is [string, string] {\n            [string, string] [username, password] \u003d result;\n            if username \u003d\u003d USER_SERVICE_USERNAME \u0026\u0026 password \u003d\u003d USER_SERVICE_PASSWORD {\n                return;\n            } else {\n                return \u003chttp:Unauthorized\u003e{body: \"Invalid credentials.\"};\n            }\n        } else {\n            return \u003chttp:Unauthorized\u003e{body: \"Invalid Base64 encoded credential.\"};\n        }\n    } else {\n        return \u003chttp:Unauthorized\u003e{body: \"Invalid \u0027Authorization\u0027 header.\"};\n    }\n}\n"}]}]}